LIBFT

// ft_isalpha --> int	ft_isalpha(char c)
# Revisa si c es una letra (mayus/minus)
# Devuelve 1 si es una letra
# Devuelve 0 si no lo es


// ft_isdigit --> int	ft_isdigit(int c)
# Revisa si c es un numero
# Devuelve 1 si es un numero
# Devuelve 0 si no lo es


// ft_isalnum --> int	ft_isalnum(int c)
# Revisa si c es una letra o un numero
# Devuelve 1 si es una letra o numero
# Devuelve 0 si no lo es


// ft_isascii --> int	ft_isascii(int c)
# Revisa si c esta dentro del rango de ascii (entre 0 y 127)
# Devuelve 1 si esta dentro del rango
# Devuelve 0 si no lo esta


// ft_isprint --> ft_isprint(int c)
# Revisa si c es un caracter imprimible (entre 32 y 126)
# Devuelve 1 si esta dentro del rango
# Devuelve 0 si no lo esta


// ft_strlen --> int	ft_strlen(char *str)
# Cuenta cuantos caracteres tiene un string
# Devuelve el numero de caracteres


// ft_memset --> void	*ft_memset(void *ptr, int c, size_t n)
# Se usa para darle el mismo valor a un bloque de memoria
 	|--> Pones el valor que quieras (letra 'a'/97 o 'A'/65, numero '4'/52)
	 |--> Especificas cunatos bytes de memoria quieres llenar con ese valor
	  |--> Se rellena con ese valor
~ void *ptr --> Puntero al array que se quiere modificar
	\--> void * es un puntero generico, se puede convertir en cualquier de dato
	 \--> para imprimrir hay que hacer un arreglo (str[] = "";)
~ int c --> Valor con el que se llenara el espacio de memoria
	\--> Se convierte en unsigned char (este es 1 byte, un numero entero entre 0 y 255)
~ size_t n --> Numero de bytes que cambiara por el nuevo valor
# Siempre sera positivo o cero (ASCII)
 	|--> char (de -128 a 127)
 	 |--> unsigned char (de 0 a 255)
# Devuelve el puntero modificado


// ft_bzero --> void	ft_bzero(void *s, size_t n)
# borra memoria (n) en el lugar donde apunta s
	\--> sustituye lo que haya por '\0'


// ft_memcpy --> void *memcpy(void *dest, const void *src, size_t n)
# copia (n) bytes de un area de memoria (*src) a otra (*dest) 
# las areas de memoria se pueden superponer, se puede perder informacion
# Devuelve el puntero que apunta a (dest)


// ft_memmove --> void	*ft_memmove(void *dest, const void *src, size_t n)
# copia (n) bytes de un area de memoria (*src) a otra (*dest)
# las areas de memoria se pueden superponer pero se asegura de NO perder informacion
	\--> copia de atras a delante para que no se sobreescriba antes de  copiarlo
# Devuelve el puntero que apunta a (dest)


// ft_strlcpy --> size_t	ft_strlcpy(char	*dest, const char *src, size_t size)
# Se usa para copiar strings de froma segura, sin desbordamiento de buffer
	\--> lo hace hasta un maximo de (size - 1)	
# Se asegura de no sobrepasar el buffer de (dest).
	\--> termina el string poniendo '\0'
# Devuelve la longitud total del string copiado


// ft_strlcat --> size_t	ft_strlcat(char *dest, const char *src, size_t size)
# Se usa para concatenar strings de froma segura, sin desbordamiento de buffer
	\--> copia (src) despues de lo que haya en (dest) respetando su tamaÃ±o
	 \--> si (dest) es 10 y (src) 15 solo copiara lo que quepa dentro de (dest)
# NO sobrepasa el buffer de dest
	\--> pone '\0' al final de (dest) si ha espacio	
# Devuelve ???


// ft_toupper --> ft_toupper(int c)
# pasa de minusculas a mayusculas
# hay que pasarle caracter por caracter

// ft_tolower --> ft_tolower(int c)
# pasa de mayusculas a minusculas
# hay que pasarle caracter por caracter


// ft_strchr --> char	*ft_strchr(const char *s, int c)
# Se usa para buscar la primera aparicion de (c) en (str)
# devuelve un puntero a la primera aparicion de (c) en (s)
	\-->  sino hay devuelve NULL
	
	
// ft_strrchr --> char	*ft_strrchr(const char *s, int c)
# Se usa para buscar la ultima aparicion de (c) en (s)
# devuelve un puntero a la ultima aparicion de (c) en (str)
	\-->  sino hay devuelve NULL
